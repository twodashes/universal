{"version":3,"sources":["json.js"],"names":["jss","val","JSON","stringify","jsp","parse","e","json_parse","value","variable","includes","replace","key","hasOwnProperty","browser","window","func","__"],"mappings":";AAoEA,aAAA,SAAA,EAAA,GAAA,OAAA,EAAA,mBAAA,QAAA,iBAAA,OAAA,SAAA,SAAA,GAAA,cAAA,GAAA,SAAA,GAAA,OAAA,GAAA,mBAAA,QAAA,EAAA,cAAA,QAAA,IAAA,OAAA,UAAA,gBAAA,IAAA,GAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,IAAA,QAAA,IAAA,QAAA,gBAAA,EApEA,IAAMA,EAAM,SAASC,GACZC,OAAAA,KAAKC,UAAUF,IAmExB,QAAA,IAAA,EAhEA,IAAMG,EAAM,SAASH,GACf,IACKC,OAAAA,KAAKG,MAAMJ,GAClB,MAAOK,GACAL,OAAAA,IA4DX,QAAA,IAAA,EAjDA,IAAMM,EAAa,SAASA,EAAWC,GACjCC,IAAAA,EAEA,GAAiB,iBAAVD,IAAuBA,EAAME,SAAS,MAAQF,EAAME,SAAS,MAClE,IACFD,EAAWP,KAAKG,MAAMG,GACtB,MAAOF,GACH,IACFG,EAAWP,KAAKG,MAAMG,EAAMG,QAAQ,WAAY,IAAIA,QAAQ,SAAU,MACtE,MAAOL,GACPG,EAAWD,EAAME,SAAS,KAAO,GAAK,SAK1CD,EAAWD,EAUT,GAAoB,WAApB,EAAOC,GAEJ,IAAA,IAAIG,KAAOH,EACTA,EAASI,eAAeD,KAE7BH,EAASG,GAAOL,EAAWE,EAASG,KAIjCH,OAAAA,GAeT,QAAA,WAAA,EATA,IAAMK,EAAU,CAAEP,WAAAA,EAAYH,IAAAA,EAAKJ,IAAAA,GACnC,GAAsB,YAAXe,oBAAAA,OAAAA,YAAAA,EAAAA,SAIJ,IAAA,IAAIC,KAFTD,OAAOE,GAAKF,OAAOE,IAAM,GAERH,EACfC,OAAOE,GAAGD,GAAQF,EAAQE","file":"json.js","sourceRoot":"../esm","sourcesContent":["const jss = function(val) {\n  return JSON.stringify(val);\n};\n\nconst jsp = function(val) {\n  try {\n    return JSON.parse(val);\n  } catch (e) {\n    return val;\n  }\n};\n\n/**\n * Parse JSON variable - recursively\n * @param {*} value - Any variable type\n * @returns {*} value - Intelligently parsed. Note: Will convert stringified number to type number!\n * NOTE: JSON can not stringify ES6 types Set and Map. Stringify/parse, changes value to empty object.\n * As a workaround, before stringifying, convert Set to Array, and Map to Array of tuples.\n */\nconst json_parse = function json_parse(value) {\n  let variable;\n  // Simple parse variable\n  if (typeof value === \"string\" && (value.includes(\"[\") || value.includes(\"{\"))) {\n    try {\n      variable = JSON.parse(value); // JSON stringified array or object\n    } catch (e) {\n      try {\n        variable = JSON.parse(value.replace(/[\\r\\n]+/g, \"\").replace(/[\\t]+/g, \" \")); // edge case\n      } catch (e) {\n        variable = value.includes(\"[\") ? [] : {}; // broken JSON array or object\n      }\n    }\n  } else if (value === \"true\" || value === \"false\" || \"null\" || \"undefined\") {\n    // boolean/null should NOT have been stringified\n    variable = value; // string\n  } else {\n    // simple value (JSON.parse converts numbers in quotes to type number)\n    try {\n      variable = JSON.parse(value); // number\n    } catch (e) {\n      variable = value; // string or undefined\n    }\n  }\n  // Parse recursively - if Object/Array\n  if (typeof variable === \"object\") {\n    // iterate all props/values\n    for (let key in variable) {\n      if (!variable.hasOwnProperty(key)) continue;\n      // parse each prop/value\n      variable[key] = json_parse(variable[key]);\n    }\n  }\n\n  return variable;\n};\n\n/*\n * EXPORT FOR BROWSER\n */\nconst browser = { json_parse, jsp, jss };\nif (typeof window === \"object\") {\n  // set up for export\n  window.__ = window.__ || {};\n  // flatten\n  for (let func in browser) {\n    window.__[func] = browser[func];\n  }\n}\n/* EXPORT FOR NODE */\nexport { json_parse, jsp, jss };\n"]}